<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Document</title>
		<style type="text/css">
			* {
				margin: 0%;
				padding: 0%;
			}

			.main {
				width: 100vw;
				height: 100vh;
			}

			.btnBox {
				width: 100%;
				height: 3rem;
				display: flex;
				justify-content: space-around;
				align-items: center;
			}

			.btnBox button {
				height: 40px;
				line-height: 40px;
				width: auto;
				padding: 0 15px;
				background: #ccc;
				border: none;
				border-radius: 10px;
				margin-bottom: 10px;
				overflow: hidden;
			}

			.video-box {
				background: #000;
				position: relative;
				width: 100%;
				height: calc(100% - 5rem);
				overflow: hidden;
				display: flex;
				flex-flow: wrap;
				align-content: flex-start;
			}

			.video {
				width: 20%;
				height: 20%;
				border: 1px solid #fff;
				overflow: hidden;
			}

			video {
				width: 100%;
				height: 100%;
			}
		</style>
	</head>

	<body>
		<div class="main">
			<div class="btnBox">
				<button type="button" onclick="startMedia()">开启本机摄像和音频</button>
				<button type="button" onclick="startConnect()">建立连接</button>
				<button type="button" id="addDeviceStream">添加设备流</button>
				<button type="button" id="addDesktopStream">添加桌面流</button>
			</div>
			<div class="video-box">
				<div class="video local-video">
					<video autoplay></video>
				</div>
				<div class="video remote-video">
					<video autoplay></video>
				</div>
				<div class="video remote-video">
					<video autoplay></video>
				</div>
				<div class="video remote-video">
					<video autoplay></video>
				</div>
				<div class="video remote-video">
					<video autoplay></video>
				</div>
				<div class="video remote-video">
					<video autoplay></video>
				</div>
				<div class="video remote-video">
					<video autoplay></video>
				</div>
				<div class="video remote-video">
					<video autoplay></video>
				</div>
				<div class="video remote-video">
					<video autoplay></video>
				</div>
				<div class="video remote-video">
					<video autoplay></video>
				</div>
				<div class="video remote-video">
					<video autoplay></video>
				</div>
				<div class="video remote-video">
					<video autoplay></video>
				</div>
			</div>
		</div>

		<script type="text/javascript">
			const userId = String(Math.round(Math.random() * 10000));
			const socketUrl = `ws://localhost:8080/msgServer/${userId}`;
			let socket;
			let peerConnected = false,
				peerConnection = null;

			const localVideo = document.querySelector('.local-video video');
			const remoteVideos = document.querySelectorAll('.remote-video');
			let remoteNum = 0;

			let localStream = null,
				desktopStream = null;

			window.onload = () => {
				socket = new WebSocket(socketUrl);
				socket.onopen = () => {
					console.log('成功连接至WebSocket服务器');
				};

				socket.onclose = (err) => {
					console.log(`与服务器断开连接: `);
					console.log(err);
				};

				socket.onmessage = (msg) => {
					console.log('=====接到来自WebSocket的消息=====');
					const evt = JSON.parse(msg.data);
					console.log(evt);
					if (evt.type === 'offer') {
						console.log('=====接收到offer,设置offer,发送answer=====');
						setOffer(evt);
						negotiation();
					} else if (evt.type === 'answer' && peerConnected) {
						console.log('=====接收到answer,设置answer SDP=====');
						setAnswer(evt);
						negotiation();
					} else if (evt.type === 'candidate' && peerConnected) {
						setCandidate(evt);
					} else if (evt.type === 'bye') {
						console.log('WebRTC通信断开');
						stop();
					}
				};
			};

			function negotiation() {
				peerConnection.onnegotiationneeded = () => {
					console.log('重新协商');
					// peerConnection.createOffer().then((sessionDescription) => {
					// 	peerConnection.setLocalDescription(sessionDescription);
					// 	sendSDP(sessionDescription);
					// });
					const localMediaStream = new MediaStream();
					for (const stream of peerConnection.getLocalStreams()) {
						for (const track of stream.getTracks()) {
							localMediaStream.addTrack(track);
						}
					}
					socket.send(
						JSON.stringify({
							type: 'bye',
						})
					);
					peerConnection.close();
					peerConnection = null;
					peerConnected = false;
					sendOffer(localMediaStream);
					peerConnected = true;
				};
			}

			function startMedia() {
				navigator.mediaDevices
					.getUserMedia({
						video: true,
						audio: true,
					})
					.then((stream) => {
						localStream = stream;
						localStream.user = userId;
						for (const track of localStream.getTracks()) {
							track.user = userId;
							track.parentStream = localStream.id;
						}
						localVideo.srcObject = localStream;
						localVideo.play();
						localVideo.volume = 0;
					})
					.catch((err) => {
						console.error(`捕获本地媒体时发生了一个错误：${err.message}`);
					});

				navigator.mediaDevices.getDisplayMedia().then((displayStream) => {
					desktopStream = displayStream;
				});
			}

			function startConnect() {
				if (!localStream) {
					alert('请先捕获本地媒体流');
				} else if (socket.readyState !== WebSocket.OPEN) {
					alert('请刷新页面');
					location.reload();
				} else {
					sendOffer(localStream);
					peerConnected = true;
				}
			}

			function sendOffer(localMediaStream) {
				peerConnection = prepareNewConnection(localMediaStream);

				peerConnection
					.createOffer()
					.then((sessionDescription) => {
						peerConnection.setLocalDescription(sessionDescription);
						sendSDP(sessionDescription);
					})
					.catch((err) => {
						console.error(`创建Offer失败：${err.message}`);
					});
			}

			function setOffer(evt) {
				peerConnection = prepareNewConnection(localStream);

				peerConnection.setRemoteDescription(new RTCSessionDescription(evt));

				console.log('=====发送Answer,创建远程会话描述=====');
				peerConnection
					.createAnswer()
					.then((sessionDescription) => {
						peerConnection.setLocalDescription(sessionDescription);
						console.log('=====创建SDP应答=====');
						sendSDP(sessionDescription);
					})
					.catch((err) => {
						console.error(`创建Answer失败：${err.message}`);
					});
			}

			function prepareNewConnection(localMediaStream) {
				const pc_config = {
					iceServers: [],
				};
				let _peerConnection = null;
				try {
					_peerConnection = new RTCPeerConnection(pc_config);
				} catch (err) {
					console.warn(`new RTCPeerConnection失败: ${err.message}`);
				}

				/**
				 * 发送所有 ICE 候选给其它对等体
				 */
				_peerConnection.onicecandidate = (evt) => {
					if (evt.candidate) {
						const candidateText = JSON.stringify({
							type: 'candidate',
							sdpMLineIndex: evt.candidate.sdpMLineIndex,
							sdpMid: evt.candidate.sdpMid,
							candidate: evt.candidate.candidate,
						});
						socket.send(candidateText);
					}
				};

				//TODO: 暂时还不知道怎么分辨是添加轨道还是减少轨道
				_peerConnection.ontrack = (event) => {
					const mediaStream = new MediaStream();
					console.log('=====检测到远程媒体流发生变化=====');
					if (event.streams && event.streams[0]) {
						console.log(event.streams);
						console.log(event.streams[0].getTracks());
						for (const track of event.streams[0].getTracks()) {
							mediaStream.addTrack(track);
						}
						remoteVideos[0].querySelector('video').srcObject = event.streams[0];
					} else {
						mediaStream.addTrack(event.track);
						console.log(mediaStream.getTracks());
					}
					// remoteVideos[0].querySelector('video').srcObject = mediaStream;
				};

				console.log('=====初始化连接轨道=====');
				const stream = localMediaStream ? localMediaStream : localStream;
				for (const track of stream.getTracks()) {
					_peerConnection.addTrack(track, stream);
				}

				return _peerConnection;
			}

			function sendSDP(sdp) {
				const sdpText = JSON.stringify(sdp);
				console.log(sdpText);
				socket.send(sdpText);
			}

			function setAnswer(evt) {
				peerConnection.setRemoteDescription(new RTCSessionDescription(evt));
			}

			function setCandidate(evt) {
				const candidate = new RTCIceCandidate({
					sdpMLineIndex: evt.sdpMLineIndex,
					sdpMid: evt.sdpMid,
					candidate: evt.candidate,
				});
				peerConnection.addIceCandidate(candidate);
			}

			function stop() {
				peerConnection.close();
				peerConnection = null;
				peerConnected = false;
			}

			document.querySelector('#addDeviceStream').onclick = () => {
				for (const sender of peerConnection.getSenders()) {
					peerConnection.removeTrack(sender);
				}
				for (const track of localStream.getTracks()) {
					peerConnection.addTrack(track, localStream);
				}
				// const senders = peerConnection.getSenders();
				// console.log(senders);
				// senders.forEach((sender) => {
				// 	sender
				// 		.replaceTrack(localStream.getTracks()[senders.indexOf(sender)])
				// 		.then((res) => {
				// 			console.log(res);
				// 		})
				// 		.catch((err) => {
				// 			console.log(err);
				// 		});
				// });
				// console.log(peerConnection.getSenders());
				// peerConnection.getTransceivers().forEach((ts) => {
				// 	console.log(ts);
				// });
			};

			document.querySelector('#addDesktopStream').onclick = () => {
				for (const sender of peerConnection.getSenders()) {
					peerConnection.removeTrack(sender);
				}
				for (const track of desktopStream.getTracks()) {
					peerConnection.addTrack(track, desktopStream);
				}
				// const senders = peerConnection.getSenders();
				// console.log(senders);
				// senders.forEach((sender) => {
				// 	if (sender.track.kind === 'video')
				// 		sender
				// 			.replaceTrack(desktopStream.getTracks()[0])
				// 			.then((res) => {
				// 				console.log(res);
				// 			})
				// 			.catch((err) => {
				// 				console.log(err);
				// 			});
				// });
				// console.log(peerConnection.getSenders());
				// peerConnection.getTransceivers().forEach((ts) => {
				// 	console.log(ts);
				// });
			};
		</script>
	</body>
</html>
